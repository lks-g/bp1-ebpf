\section{Teoretické základy eBPF}
V súčasnej dobe sa operačné systémy stávajú čoraz komplexnejšími, s rastúcim počtom aplikácií a služieb, ktoré sa na týchto systémoch spúšťajú, 
rastie aj potreba zabezpečenia pred rôznymi bezpečnostnými rizikami a hrozbami. Jedným z nástrojov, ktorý sa používa na zlepšenie bezpečnosti v 
operačných systémoch Linux, je eBPF (extended Berkeley Packet Filter). Je to flexibilný a mocný nástroj, ktorý sa čoraz častejšie používa na 
rôzne účely v operačných systémoch, ako je napríklad monitorovanie a filtrovanie sieťovej aktivity, optimalizáciu výkonu operačného systému, 
alebo detegovanie útokov a škodlivého kódu. Taktiež je čoraz častejšie používaný pre implementáciu rôznych nástrojov slúžiacich na analýzu dát 
a monitorovanie systémov, ako napríklad nástroj \emph{perf}, ktorý umožňuje profilovanie výkonu aplikácií v operačnom systéme. Pre maximálny výkon a 
bezpečnosť systému je dôležité, aby bol eBPF správne nakonfigurovaný a používaný pretože môže spôsobiť veľké problémy pri zlom zaobchádzaní.~\cite{eBPF}

\subsection{História eBPF}
História eBPF sa začína s technológiou nazývanou \emph{Berkeley Packet Filter} v skratke BPF, ktorá vznikla v národnom laboratóriu Lawrenca Berkeleyho, 
kde ju 19. Decembra 1992 opísali Steven McCanne spolu s Vanom Jacobsonom. BPF bol navrhnutý ako jednoduchý jazyk pre filtrovanie sieťových paketov, 
ktorý bol implementovaný ako rozšírenie jadra operačného systému. Jeho hlavným cieľom bolo umožniť používateľom filtrovať sieťové pakety bez nutnosti 
používať externé nástroje ako napríklad \texttt{tcpdump}. BPF bol úspešne implementovaný v operačných systémoch ako \emph{BSD} a Linux a stal sa jedným z 
kľúčových nástrojov pre sieťovú diagnostiku a analýzu. Avšak, s rastúcimi požiadavkami na funkcionalitu a výkon, bolo potrebné rozšíriť BPF o ďalšie možnosti. 
Začiatkom 21. storočia sa začal vývoj zameraný na vylepšenie technológie BPF. Nová verzia nazvaná eBPF (\emph{extended Berkeley Packet Filter}) vznikla ako 
rozšírenie k BPF, ktoré bolo navrhnuté tak, aby poskytlo viac funkcií a umožňovalo vykonávať komplexnejšie filtračné skripty na sieťových paketoch. 
Tento nástroj bol prebratý Linuxovou komunitou, kde sa stal veľmi populárnym pre rôzne účely a v roku 2014 bol implementovaný do jadra Linuxu. 
Medzi hlavné rozdiely medzi BPF a eBPF patrí podpora pre x86 a arm architektúry, možnosť spustiť aplikácie v jadre operačného systému a možnosť 
vykonávať viac operácií ako len filtrovanie sieťových paketov. V súčasnosti eBPF umožňuje používateľom načítať a spustiť vlastné programy vo 
virtuálnom priestore (\emph{sandboxe}) v rámci jadra operačného systému. To znamená, že môže rozšíriť alebo dokonca upraviť spôsob, akým sa jadro správa 
bez zmeny zdrojového kódu jadra. Programy spustené týmto spôsobom sú schopné monitorovať systém, zhromažďovať metriky, a dokonca aj vykonávať 
rôzne úlohy ako napríklad sledovanie a upravovanie sieťovej aktivity. Vďaka týmto rozšíreniam sa eBPF stal veľmi flexibilným nástrojom pre 
riešenie rôznych problémov v oblasti sieťovej diagnostiky, monitorovania systému a izolácie kontajnerov.~\cite{eBPF, history, wiki} 

\subsection{Princípy eBPF}
\subsubsection{Ako funguje eBPF} 
eBPF programy sú riadené udalosťami a spúšťajú sa, keď jadro alebo aplikácia prejde určitým bodom hookom. Preddefinované hooky zahŕňajú systémové volania, vstup/výstup funkcií, sledovacie body jadra, sieťové udalosti a niekoľko ďalších.
Ak pre konkrétnu požiadavku neexistuje preddefinovaný hook, je možné vytvoriť \texttt{kernel probe (\texttt{kprobe})} alebo \texttt{user probe} (\texttt{uprobe}) na pripojenie eBPF programov takmer kdekoľvek v užívateľských aplikáciách alebo jadre.

\subsubsection{Ako sa píšu programy eBPF}
V mnohých scenároch sa eBPF nepoužíva priamo, ale nepriamo prostredníctvom projektov ako je napríklad Cilium, bcc alebo bpftrace, ktoré poskytujú abstrakciu nad eBPF a nevyžadujú priame písanie programov, ale namiesto toho ponúkajú možnosť špecifikovať definície založené na zámeroch, ktoré sa potom implementujú pomocou eBPF.
Ak neexistuje abstrakcia vyššej úrovne, je potrebné programy písať priamo. Jadro Linuxu očakáva, že programy eBPF budú načítané vo forme bajtkódu (\texttt{bytecode}). Aj keď je samozrejme možné napísať bytecode priamo, bežnejšou vývojovou praxou je využitie kompilátora, ako je LLVM, na kompiláciu pseudo-C kódu do eBPF bajtkódu.

\subsection{Architektúra eBPF}
\subsubsection{Kompilácia JIT}
Krok kompilácie \texttt{Just-in-Time} (\texttt{JIT}) prekladá všeobecný bajtový kód programu do inštrukčnej sady špecifickej pre stroj s cieľom optimalizovať rýchlosť vykonávania programu. Vďaka tomu sa programy eBPF spúšťajú rovnako efektívne ako natívne skompilovaný kód jadra alebo ako kód načítaný ako modul jadra.

\subsubsection{eBPF Maps}
Dôležitým aspektom programov eBPF je schopnosť zdieľať zhromaždené informácie a ukladať stav. Na tento účel môžu programy eBPF využívať koncept máp pre ukladanie a načítavanie údajov v širokom súbore dátových štruktúr. K mapám možno pristupovať z eBPF programov, ako aj z aplikácií v používateľskom priestore prostredníctvom systémového volania.

\subsubsection{eBPF Helpers}
eBPF programy nemôžu volať ľubovoľné funkcie jadra. Ak by sa to povolilo, programy eBPF by sa viazali na konkrétne verzie jadra a skomplikovala by sa kompatibilita programov. Namiesto toho môžu programy eBPF uskutočňovať volania funkcií do pomocných funkcií, čo je dobre známe a stabilné API, ktoré jadro ponúka.
Súbor dostupných pomocných volaní sa neustále vyvíja. Príklady dostupných pomocných volaní:
\begin{itemize}
\item Prístup k mape eBPF
\item Generovanie náhodných čísel
\item Získať aktuálny čas a dátum
\item Získať kontext procesu/skupiny
\item Manipulácia so sieťovými paketmi a logika presmerovania
\end{itemize}

\subsection{eBPF nástroje}
Programovanie eBPF je neuveriteľne výkonné, ale aj zložité. Z toho dôvodu vzniklo niekoľko projektov a dodávateľov, ktorí stavajú na platforme eBPF s cieľom vytvoriť novú generáciu nástrojov, ktoré budú pokrývať pozorovateľnosť, bezpečnosť, sieťovanie a ďalej.

\subsubsection{Knižnica libbpf C/C++}
je generická knižnica eBPF založená na jazyku C/C++, ktorá pomáha oddeliť načítavanie objektových súborov eBPF generovaných kompilátorom clang/LLVM do jadra a vo všeobecnosti abstrahuje interakciu so systémovým volaním BPF poskytovaním ľahko použiteľných API knižníc pre aplikácie.

\subsubsection{BCC}
Umožňuje používateľom písať programy v jazyku python s vloženými programami eBPF.  
Tento framework je primárne zameraný na prípady použitia, ktoré zahŕňajú profilovanie/sledovanie aplikácií a systémov, kde sa program eBPF používa na zber štatistík alebo generovanie udalostí
V používateľskom priestore zbiera údaje a zobrazuje ich v ľudsky čitateľnej forme. 

\subsubsection{bpftrace}
bpftrace je vysokoúrovňový trasovací jazyk pre Linux eBPF, ktorý je k dispozícii v jadrách Linuxu od verzie 4.x. 
bpftrace používa LLVM ako backend na kompiláciu skriptov do bajtkódu eBPF a využíva BCC na interakciu s linuxovým subsystémom eBPF, ako aj existujúce možnosti trasovania Linuxu
Jazyk bpftrace je inšpirovaný jazykmi awk, C a predchádzajúcimi trasovačmi, ako sú DTrace a SystemTap.

\subsubsection{Knižnica eBPF Go}
poskytuje všeobecnú knižnicu eBPF, ktorá oddeľuje proces získania bajtkódu eBPF, načítanie a správu programov eBPF. 
Programy eBPF sa zvyčajne vytvárajú napísaním jazyka vyššej úrovne a potom sa pomocou kompilátora clang/LLVM skompilujú do bajtkódu eBPF.


\subsection{Použitie eBPF}
\subsubsection{Bezpečnosť a eBPF}
Počas vývoja eBPF bola bezpečnosť najdôležitejším aspektom pri zvažovaní začlenenia eBPF do jadra Linuxu. 
eBPF bezpečnosť je zabezpečená prostredníctvom niekoľkých vrstiev:

\subsubsection*{Požadované oprávnenia}
Pokiaľ nie je povolený neprivilegovaný eBPF, všetky procesy, ktoré majú v úmysle načítať programy eBPF do jadra Linuxu, musia byť spustené v privilegovanom režime (root) alebo musia vyžadovať schopnosť \texttt{CAP\_BPF}. To znamená, že nedôveryhodné programy nemôžu načítať programy eBPF.
Ak je zapnutý neprivilegovaný režim eBPF, neprivilegované procesy môžu načítať určité programy eBPF s výhradou obmedzenej sady funkcií a s obmedzeným prístupom k jadru.

\subsubsection*{Overovač (Verifier)}
Ak je procesu povolené načítať program eBPF, všetky programy stále prechádzajú cez overovač eBPF. Overovač eBPF zabezpečuje bezpečnosť samotného programu. To znamená, že napr:
\begin{itemize}
\item Programy eBPF môžu obsahovať tzv. ohraničené slučky, ale program je prijatý len vtedy, ak overovateľ môže zabezpečiť, že slučka obsahuje výstupnú podmienku, ktorá sa zaručene stane pravdivou.
\item Programy nesmú používať žiadne neinicializované premenné ani pristupovať do pamäte mimo hraníc.
\item Programy sa musia zmestiť do požiadaviek na veľkosť systému. Nie je možné načítať ľubovoľne veľké programy eBPF.
\item Program musí mať konečnú zložitosť. Overovač vyhodnotí všetky možné cesty vykonávania a musí byť schopný dokončiť analýzu v medziach nakonfigurovanej hornej hranice zložitosti.
\end{itemize}

\subsubsection*{Hardening (Tvrdenie)}
Po úspešnom dokončení overovania program eBPF prejde procesom „tvrdenia“ podľa toho, či je program načítaný z privilegovaného alebo neprivilegovaného procesu. Tento krok zahŕňa:
Ochranu vykonávania programu: 
Pamäť jadra, v ktorej sa nachádza program eBPF, je chránená a je určená len na čítanie. Pokiaľ sa program pokúsi niečo modifikovať, jadro sa zrúti aby neumožnilo pokračovať vo vykonávaní poškodeného/manipulovaného programu.
Zmiernenie proti Spectre: 
Pri špekulácii môžu procesory nesprávne predpovedať vetvy a zanechať pozorovateľné vedľajšie efekty, ktoré by sa mohli extrahovať prostredníctvom bočného kanála.
Konštantné zaslepenie: 
Všetky konštanty v kóde sú zaslepené, aby sa zabránilo útokom JIT spraying.

\subsubsection{Seccomp}
Mechanizmus seccomp() umožňuje procesu načítať BPF program na obmedzenie jeho budúceho používania systémových volaní.
Jedná sa o jednoduchý, ale flexibilný mechanizmus sandboxingu, ktorý sa široko používa. 
Tieto filtračné programy však bežia na "klasickom" virtuálnom stroji BPF, a nie na rozšírenom stroji eBPF, ktorý sa používa na iných miestach jadra. 
Účelom programu BPF pod funkciou seccomp() je rozhodovať o tom, či má byť dané systémové volanie povolené.
Prechodom na eBPF by sa seccomp() programom sprístupnilo množstvo nových funkcií vrátane máp, pomocných funkcií, ukladania na jednotlivé úlohy, expresívnejšej inštrukčnej sady a ďalších. 
Programy pre eBPF možno písať v jazyku C, čo nie je možné pre programy klasického BPF. 
Tento problém, viedol k vytvoreniu špeciálnych jazykov, ako je easyseccomp. 
Kvôli bezpečnostným problémom nie je zatiaľ možné integrovať eBPF do systému seccomp()

* Jedným z prvých použití virtuálneho stroja BPF mimo siete bola implementácia politík kontroly prístupu pre systémové volanie seccomp(). [2]

\subsubsection{LSM (Linux Security Modules)}
Framework bezpečnostného modulu Linuxu (LSM) poskytuje mechanizmus na pripojenie rôznych bezpečnostných kontrol pomocou nových rozšírení jadra. Primárnymi používateľmi rozhrania LSM sú rozšírenia MAC (Mandatory Access Control), ktoré poskytujú komplexnú bezpečnostnú politiku. Okrem väčších rozšírení MAC možno pomocou rozhrania LSM vytvárať aj ďalšie rozšírenia, ktoré poskytujú špecifické zmeny fungovania systému, ak tieto úpravy nie sú k dispozícii v základnej funkcii samotného systému Linux. [3]
Z pohľadu bezpečnostného správania sa lepšie mapuje na LSM ako na filtre seccomp, ktoré sú založené na zachytávaní syscallov. Rôzne bezpečnostné správanie sa môže realizovať prostredníctvom viacerých systémových volaní, takže by bolo ľahké jedno alebo viacero z nich prehliadnuť, zatiaľ čo hooky LSM zachytávajú správanie, ktoré je predmetom záujmu. Zámerom je, aby eBPF helpre boli "presné a granulárne". Na rozdiel od API sledovania BPF nebudú mať všeobecný prístup k vnútorným dátovým štruktúram jadra. 
KRSI vyžaduje na svoju prácu \texttt{/CAP\_SYS\_ADMIN}.
* \texttt{/CAP\_SYS\_ADMIN} je potrebný na vykonávanie celého radu administratívnych operácií, ktoré je ťažké z kontajnerov vypustiť, ak sa v kontajneri vykonávajú privilegované operácie.

\subsubsection{KRSI}
Prototyp KRSI je implementovaný ako bezpečnostný modul Linuxu (LSM), ktorý umožňuje pripojenie programov eBPF k bezpečnostným hákom jadra.

Hlavným cieľom KRSI je sledovať celkové správanie systému za účelom odhalenia útokov. 
KRSI exportuje novú hierarchiu súborového systému pod \texttt{/sys/kernel/security/bpf} s jedným súborom pre každý hák.
K danému háku môže byť pripojených viac ako jeden program.
Pri každom volaní bezpečnostného háku sa postupne zavolajú všetky pripojené programy BPF, a ak niektorý program BPF vráti chybový stav, požadovaná akcia sa zamietne.

\subsubsection*{KRSI vs Landlock} 
KRSI je nástroj pre správcov systému, ktorí sa zaujímajú o monitorovanie správania systému ako celku.
Landlock je určený na to, aby umožnil neprivilegovaným používateľom sandboxovať programy, ktoré spúšťajú.  
Na pripojenie programu BPF k háku prostredníctvom Landlock nie sú potrebné žiadne oprávnenia.

\section{Aplikácie eBPF}
\subsubsection{Detekcia útokov}
\section{Porovnanie eBPF s inými nástrojmi}
\section{Implementácia vlastného riešenia pomocou eBPF}
\section{Testovanie a vyhodnotenie výsledkov implementácie}














